\documentclass{article}
\newcommand{\fido}{\texttt{fido}}
\newcommand{\lagos}{\texttt{lagos}}
\newcommand{\raven}{\texttt{raven}}
\newcommand{\ndel}{\texttt{deliverator}}
\newcommand{\del}{the \texttt{deliverator}}
\newcommand{\enki}{\texttt{enki}}
\newcommand{\enzo}{\texttt{enzo}}
\newcommand{\yt}{\texttt{yt}}
\newcommand{\hd}{HippoDraw}
\usepackage{fullpage}
\usepackage{graphicx}
\title{\yt\ - an \enzo\ toolkit}
\author{Matthew Turk, Stanford University \\(\texttt{mturk@slac.stanford.edu})}
\begin{document}
\maketitle
\tableofcontents
\clearpage
\section{Introduction}
I'll be short.  I am writing this manual like I am the only person who has
contributed to this codebase.  While I am no doubt the primary author, great
contributions have been made by John Wise, Tom Abel and Ji-hoon Kim.  The point
of this toolkit was to get my own research done quicker, and to provide an easy
way to conduct analysis -- without having to write in C, or having to wait for
an IDL license, or -- and this was important -- ever having to write an
explicit loop over coordinates.  It started out as a simple way of plotting
slices of AMR data in \hd, but thanks to lots of brain storming -- as well as
the increased needs of my own research -- it has expanded to include many other
functions.

There are several components to \yt, and their flow is described in Figure
\ref{yt_flow}.

\begin{itemize}
\item[\yt] The base class consists of a logger, a primitive (and deprecated)
shell, a configuration file reader, and a module for switching between array
engines.
\item[\lagos] Handles \enzo\ data.  It consists of the
classes for handling grids, parameter files, hierarchies, ``run'' containers,
derived fields, and for reading of HDF files.
\item[\fido] Moves around data, keeps track of runs, archives, and watches an
in-progress run.  Function calls can be spawned when new data arrives.  Can
also unarchive and `branch' runs.
\item[\raven] Displays graphics.  (Initially called \raven\ because it `sliced'
\enzo\ data, \raven\ is now the primary method of plotting.)  Currently only
2-D capable, with primary interface to \hd\ but preliminary support for
matplotlib.
\item[\enki] Handles creation of \enzo\ runs, restarting runs, recompiling from
source trees, and launching parallel jobs.  Interaction with \enzo\ via
SWIG\footnote{http://www.swig.org/} takes
place through \enki.  Currently, \enki\ is largely at a primitive state, although
the SWIG interface is exposed, and highly useful.
\item[\ndel] Supplies images to the user, through a parameter-query interface.
\end{itemize}

\begin{centering}
\begin{figure}[tbh!]
\includegraphics[width=0.85\textwidth]{yt_flow_diagram.png}
\caption{\label{yt_flow}Flow diagram for \yt.}
\end{figure}
\end{centering}

I hope that you will find this manual helpful, and that you find \yt\ as useful as
I do.  I encourage you to play with it, change things, make improvements -- but if
you do, be sure to share with everyone else.  Nobody likes stinginess.

\clearpage
\section{Setup and Requirements}

If you're going to be using \yt\ on global SLAC systems, there is probably already
a copy installed.

\vspace{0.25in}
\begin{tabular}{ll}
Host & Base Directory \\ \hline
\texttt{ia32} & \texttt{/nfs/slac/g/ki/ki12/mturk/ia32\_local/} \\
\texttt{red} & \texttt{/usr/work/mturk/local/} \\
\texttt{red} (beta) & \texttt{/usr/work/mturk/local-testing/}
\end{tabular}
\vspace{0.25in}

Otherwise, you will have to install it yourself, along with the attendant packages.
Installing the packages required for \yt\ is not difficult; however, some of the
packages (specifically \hd) require several other packages.

\begin{enumerate}
\item Python 2.4 or higher (\texttt{http://www.python.org/})
\item SciPy (\texttt{http://scipy.org/})
\item NumPy (\texttt{http://numpy.scipy.org/})
\item PyHDF (0.7-5 or higher) or PyTables (with NumPy support)
\item HippoDraw (optional)
\item matplotlib (\texttt{http://matplotlib.sf.net/}) (optional)
\end{enumerate}

I recommend using the script \texttt{ez\_setup.py}, which automates much of the
installation process for Python packages.  If you are missing a package, simply
type \texttt{easy\_install} \textit{packagename} before searching any further.
Additionally, sources for most of these are kept in
\texttt{/usr/work/mturk/local/src/} on \texttt{red}.

Once you have installed the appropriate packages, simply check out the module
\texttt{enzo/tools/yt} from CVS, and run \texttt{python setup.py install} to
complete the installation.

\clearpage
\section{Simple Examples}

Alright, so now you've got it installed, and you've got a dataset, and you want to
do something fun.  To start with, for all of the examples in this document, we will
assume that you have already set up your environment, importing the correct
modules, etc.  (If you are working in the \yt\ interactive shell, this is done for
you already, and many shortcuts exist for common tasks.)  
An example setup is showing in figure \ref{env_setup}.  If you are going to write
standalone scripts, a variant of this code listing will most likely have to be at
the top of every standalone script.  Again, the interactive shell provides many
shortcuts making much of this section obsolete, but that will be addressed later.

\begin{figure}[tbh!]
\begin{verbatim}
import yt
import yt.lagos as lagos
import yt.fido as fido
import yt.raven as raven
import yt.enki as enki
import numpy as na
\end{verbatim}
\caption{\label{env_setup}Code listing showing environment setup.}
\end{figure}

Let's say that you have an \enzo\ output named \texttt{RedshiftOutput0010}, and you
want to create a plot of the \texttt{Density} field, sliced at the point of maximum
density, along all three axes.

\begin{verbatim}
myHierarchy = lagos.EnzoHierarchy("RedshiftOutput0010")
myHippo = raven.EnzoHippo(myHierarchy)
myHippo.addSlice("Density")
\end{verbatim}

This will create instances of \texttt{EnzoHierarchy}, \texttt{EnzoHippo} and then
slice the data along all three axes, plotting the resultant images to a \hd\
canvas.  \yt\ does its best to figure out physical units, as well -- as such, you
can issue commands like the following:

\begin{verbatim}
myHippo.setWidth(1,"kpc")
myHippo.setWidth(1000,"pc")
\end{verbatim}

and they should work.  (Note that $1000\mbox{pc} = 1\mbox{kpc}$ so the two commands
are identical.  Additionally, if instead of \texttt{"kpc"} you were to use either
\texttt{"1"} or \texttt{1}, it would assume the width was fed in code units.)

At this point, it is important that I note two Python commands that are exceedingly
useful: \texttt{dir} and \texttt{help}.  The code listing in figure
\ref{dir_and_help} shows what the output of those commands looks like, for
\texttt{EnzoHippo}.

\begin{figure}
\begin{verbatim}
>>> dir(raven.EnzoHippo)
['__del__', '__doc__', '__init__', '__module__', 'addClusterOutput', 'addNewProj',
 'addProj', 'addRadialProfilePlot', 'addRadialScatterPlot', 'addSlice',
 'addThreePhase', 'addTwoPhase', 'getWidth', 'saveImages', 'setCenter', 'setWidth',
 'setZRange']

>>> help(raven.EnzoHippo.addSlice)
Help on method addSlice in module yt.raven.EnzoHippoType:

addSlice(self, field='Density', axis=None, center=None, cmap=None)
    unbound yt.raven.EnzoHippoType.EnzoHippo method

    Add a new plot of this type
    @param field: the field to add to the slice
    @type field: string
    @keyword axis: the axis to slice along (defaults to all three)
    @type axis: integer, list of integers
    @keyword center: the center (defaults to maximum Density)
    @type center: tuple of floats
    @keyword cmap: the colormap
    @type cmap: string
    @return: L{EnzoVMSlice<EnzoPlotTypes.EnzoVMSlice>}

>>>
\end{verbatim}
\caption{\label{dir_and_help}The output of the \texttt{dir} and \texttt{help}
commands}
\end{figure}

All parameters are described, and all member functions are listed.  Additionally,
the output from these is parsed and put online, in a cross-referenced\footnote{The
manual is kept up-to-date via the source code, and while the parameters to a
function are usually listed, the return values are sometimes less well-documented.}
 manual, at \texttt{http://www.slac.stanford.edu/\~{}mturk/yt\_doc/} .  As you can
see already, the \texttt{addSlice} method also includes options for color maps, a
center, and the axis (0,1,2) along which to slice.  Calling
\texttt{help(raven.EnzoHippo)} should give you an idea of the other types of plots
that are available.

So that's all well and good for plotting with \hd, but what if you simply want to
\textit{look} at some data?  The hierarchy object (\texttt{myHierarchy} in our
example) has member \texttt{EnzoGrids}, accessible via the \texttt{grids} array.

\begin{verbatim}
>>> g = myHierarchy.grids[0]
>>> print g
1
>>>
\end{verbatim}

Note that printing the grid returns the grid's ``id'' and not its index in the
\texttt{grids} array.  This is important, because these are off-by-one -- in \enzo\
the grids are 1-indexed, but in \yt\ they are 0-indexed.  All \texttt{EnzoGrid}
instances are overloaded, so that accessing them like a Python dictionary will
return the field fed in as a key.  For instance, calling \texttt{g["Density"]}
will return the entire density field in an array.

Additionally, as we will discuss later, derived fields are all automatically
generated.  If you want to access the entropy for a given grid, you can access it
directly, and \yt\ will generate that field automaticall and return it.  (This
works for slices, projections, and all other plots, as well.)

\clearpage
\section{\fido\ Usage}

\fido\ archives and accesses data.  It can be accessed via command line
functions, such as \texttt{fimport}, \texttt{fbury}, \texttt{frevert},
\texttt{frecomp}, and, most importantly, \texttt{fido}.  However, \fido\ is
also exposed through the module \texttt{yt.fido}.

By itself, \fido\ simply archives data. 

\begin{verbatim}
Usage: fido [options]

Archives data and creates plots.

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -c CFGFILE, --config=CFGFILE
  -p PATH, --path=PATH  Where to move files when archiving
  -d, --deliverator     Should we submit to the Deliverator? (This requires
                        that httpPrefix be defined in [raven] in your yt
                        config file!)
\end{verbatim}

If you ask it to, it will look for a plot-descriptor file --  every time it
grabs an output and puts it where it ought to be it forks a process, interprets
the file, and outputs plots as appropriate.  All of the primary plots available
in \raven\ are available through \fido\'s automated mode.  A sample plot
configuration file looks something like this:

\begin{verbatim}
<raven>
    <proj mindx="1">
        <field weight="Temperature">Density</field>
        <width unit="au">10</width>
        <width unit="rsun">1</width>
    </proj>
    <slice mindx="1">
        <field>H2I_Fraction</field>
        <field>Temperature</field>
        <field>NumberDensity</field>
        <field>RadialVelocity</field>
        <width unit="au">10000</width>
        <width unit="pc">1</width>
    </slice>
    <threephase mindx="1">
        <field>NumberDensity</field>
        <field>Temperature</field>
        <field>H2I_Fraction</field>
        <width unit="rsun">100</width>
    </threephase>
    <twophase mindx="1">
        <field>NumberDensity</field>
        <field>Temperature</field>
        <width unit="rsun">100</width>
    </twophase>
</raven>
\end{verbatim}

The format of the file is fairly self-explanatory; however, a few notes should
be made.  The parameter \texttt{mindx} refers to the number of
finest-resolution cells that each plot should contain on a side in order for
the plot to be made.  For the \texttt{slice}-type plot, each field listed will
be output at each resolution.

\clearpage
\section{Interactive Shell}

SciPy (\textt{http://scipy.org/}) is an amazing distribution, and one of its
subpackages, IPython, creates an excellent environment for interactive data
exploration.  Lots of IPython information can be found on the IPython website
(\texttt{http://ipython.scipy.org/}) including examples of neat things you can
do (simple, single-command multithreading, for instance) and different ways to
customize the experience.

Rather than belabor the description of IPython, let's talk about a few of the
features of the '\yt\' profile.

\clearpage
\section{Important Classes}

\clearpage
\section{Other Bits that Don't Fit}

\clearpage
\section{Extending}

\clearpage
\section{Other Resources}

\end{document}
